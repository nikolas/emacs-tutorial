#+TITLE: The Emacs Lisp Introduction Tutorial
#+AUTHOR: Marcin Borkowski

* Introduction
This tutorial is meant to get you started with Emacs Lisp.

Nearly everything covered by this short tutorial (and much, much more)
can be learned from the official Emacs documentation (reading of which
I strongly recommend, especially the excellent Robert J. Chassell's
book, "Introduction to Programming in Emacs Lisp", which you can
access in Emacs by typing =C-h i d m emacs lisp intro RET= and which
is another introductory text on Emacs Lisp).  If you prefer, however,
to learn by doing, this tutorial may serve (hopefully) as a useful
assistance.

We do not assume knowledge of programing in general or in any language
in particular, but for the sake of those readers who happen to know
some popular programming language(s), remarks comparing Emacs Lisp to
them are sprinkled throughout the text.  You don't lose anything
important if you skip or don't understand them.

* Introduction to Emacs Lisp
Emacs Lisp is a member of the ancient and noble family of Lisp
programming languages.  (Its name is sometimes shortened to Elisp, and
we will use the more generic word "Lisp" from time to time, too.
There are excellent articles about the history of Lisp, and the
reasons it looks like this, so we will jump straight into examples.

A Lisp program consists of a sequence of /expressions/.  Each of them
is /evaluated/ in succession, and the evaluation of each one results
in a /value/ (we say that an expression /returns/ the value, or that
it /evaluates/ to it.).  Notice that there are no /statements/ in
Lisp, unlike languages like C or Python.  The thing closest to
a "statement" in Lisp is an expression whose value is not used.

An expression may be an /atom/.  An atom can be a /literal value/,
like a number or a string of characters, or something called
a /symbol/, which is a Lispy way of saying "a name for something".  (A
Lisp "symbol" is close to what other languages call an "identifier".
Lisp does not have a notion of a "reserved keyword".)  The rules to
decide which is which are rather simple: a /string/ is a sequence of
characters other than quotation marks, surrounded by quotation marks,
like ="string"=; a /number/ is something consisting of digits and
possibly a sign, a decimal point and an exponent part, formed in an
appropriate way, like =-12.34e8= or =31=, and a symbol is a sequence
of "normal" characters -- most often lowercase letters, dashes and
a few others.  (It may even have digits, provided they do not form
a number; =+1= is not a symbol, while =1+= is.)  These rules are not
comprehensive (they are so simplified to be even wrong!), but they
suffice for the most cases.  There are also more kinds, or /types/, of
literal values, but they are fairly advanced and we will not cover
them in this tutorial.

An expression consisting of a literal value evaluates to itself: the
value of the expression =3.1416= is, unsurprisingly, the number
3.1416.  An expression consisting of a symbol evaluates the thing the
symbol names; if there is no such thing, an error occurs.

An expression is often a /list/, i.e., a sequence of /elements/,
separated by whitespace, and enclosed in parentheses, like this:

#+BEGIN_EXAMPLE
  (This is a list.)
#+END_EXAMPLE

The above list consists of four elements, and each of them is
a symbol.  Elements of lists need not be symbols.  They can be
literals (i.e., actual /values/), like numbers or strings, or even
other lists.

#+BEGIN_EXAMPLE
  ((This list) has 4 "elements.")
#+END_EXAMPLE

The first element of the above list is itself a list (consisting of
two elements -- both symbols), then another symbol, then a number,
then a string.

Not every list is a good candidate for an /expression/, though.  For
a list to serve as that, the first element should be something
special: most often, a symbol describing /what/ we want to happen.
The rest of the elements should explain /in what way/ we want that to
happen.  (The first element can be thought of as a /verb/ describing
an action, and the rest as /nouns/, objects for that action.)

Here is a simple example of a well-formed expression:

#+BEGIN_SRC elisp
  (+ 52 55)
#+END_SRC

It is not difficult to guess what it evaluates to.  How do we find out
whether we guessed correctly?

* Practicing Evaluation
There are quite a few ways for the Emacs user to evaluate an
expression and check what value it returns.  One of them is the aptly
named =eval-expression= command, by default bound to =M-:=.  Try it
now: press =M-:=, then type =(+ 52 55)= (don't forget the spaces!),
and hit =RET=.  You should see something like this:
#+BEGIN_EXAMPLE
107 (#o153, #x6b, ?k)
#+END_EXAMPLE
The result might be a bit surprising -- you probably expected to see
just =113= -- but when evaluating expressions returning whole numbers,
it is occasionally useful to see also the octal (153) and hexadecimal
(6b) values of the expression as well as the character whose code is
the expression's value, so that is what Emacs shows in this case.

Of course, retyping the expression you already have in some buffer is
not what you would like to do.  You may of course kill the expression
and yank it in the minibuffer when presented with the =M-:= prompt,
but there is another way.  In any mode (except maybe some really
exotic ones), you can place the point /after/ an expression and press
=C-x C-e= (or =M-x eval-last-sexp=).  (The "sexp" part is an
abbreviation of "s-expression", a fancy name for Lisp's kind of
expressions -- the ones enclosed in parentheses, and where the "verb"
comes at the beginning.)

You may now try evaluating various expressions, which sometimes leads
to surprises.  Try to guess what value the following expressions
return (some of them are cases of constructions we will cover later):

#+BEGIN_SRC elisp
  (/ 12 5)
  (/ 12 5.0)
  (* (+ 2 3) (/ 16 4))
  (concat "foo" "bar")
  (sleep-for 4)
  (point)
  (current-buffer)
  (buffer-name (current-buffer))
  (if (= 0 1)
      (message "Something is fishy!")
    (message "Numbers work as expected."))
  (mapcar #'sqrt '(1 2 3 4))
  (setq foo 42)
  (* foo foo)
#+END_SRC

Notice that the third expression is different than the others, in that
it contains another expression as one of its parts.  It is perfectly
valid -- and in fact, used all the time in Lisp programs -- since it
is the basic way of combining simple expressions to form more complex
ones.  When Emacs computes the value of an expression, and one of its
parts is an expression itself, Emacs pauses for a moment, computes the
value of the subexpression, and then substitutes the computed value in
place of that subexpression.  It is even possible (and very useful)
for the subexpression to contain further subexpressions, and this
chain is automatically properly resolved.

As you can see from some of the above examples, there exist various
"verbs" that can come as the first symbol in an expression.  In fact,
there exist /thousands/ of them -- the more packages you have
installed in your Emacs, the more such symbols exist.  (In my Emacs,
when I am typing this, I have 25849 of them.  In stock Emacs, without
any packages, there are more than 6000 of them.)  This number may seem
intimidating, but just like when learning a natural language, you do
not have to know all them to be able to communicate with its native
speakers comfortably.  Even if you know only a few dozen, you can
express quite a few things, and Emacs has much better facilities than
an ordinary dictionary to learn new ones.

There are more ways to evaluate Emacs Lisp expressions, but the ones
we have covered are enough for now.  Let us move on to explaining some
of the magic behind the example expressions above!

* Making lists and quoting

* Conditionals

* Looping

* Side effects

* Variables and assignment

* Functions

* Commands

* Introduction to debugging

* Potentially useful packages for Lisp editing
