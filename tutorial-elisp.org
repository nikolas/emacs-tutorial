#+TITLE: The Emacs Lisp Introduction Tutorial
#+AUTHOR: Marcin Borkowski

* Introduction
This tutorial is meant to get you started with Emacs Lisp.

Nearly everything covered by this short tutorial (and much, much more)
can be learned from the official Emacs documentation (reading of which
I strongly recommend, especially the excellent Robert J. Chassell's
book, "Introduction to Programming in Emacs Lisp", which you can
access in Emacs by typing =C-h i d m emacs lisp intro RET= and which
is another introductory text on Emacs Lisp).  If you prefer, however,
to learn by doing, this tutorial may serve (hopefully) as a useful
assistance.

We do not assume knowledge of programing in general or in any language
in particular, but for the sake of those readers who happen to know
some popular programming language(s), remarks comparing Emacs Lisp to
them are sprinkled throughout the text.  You don't lose anything
important if you skip or don't understand them.

* Introduction to Emacs Lisp
Emacs Lisp is a member of the ancient and noble family of Lisp
programming languages.  (Its name is sometimes shortened to Elisp, and
we will use the more generic word "Lisp" from time to time, too.
There are excellent articles about the history of Lisp, and the
reasons it looks like this, so we will jump straight into examples.

A Lisp program consists of a sequence of /expressions/.  Each of them
is /evaluated/ in succession, and the evaluation of each one results
in a /value/ (we say that an expression /returns/ the value, or that
it /evaluates/ to it.).  Notice that there are no /statements/ in
Lisp, unlike languages like C or Python.  The thing closest to
a "statement" in Lisp is an expression whose value is not used.

An expression may be an /atom/.  An atom can be a /literal value/,
like a number or a string of characters, or something called
a /symbol/, which is a Lispy way of saying "a name for something".  (A
Lisp "symbol" is close to what other languages call an "identifier".
Lisp does not have a notion of a "reserved keyword".)  The rules to
decide which is which are rather simple: a /string/ is a sequence of
characters other than quotation marks, surrounded by quotation marks,
like ="string"=; a /number/ is something consisting of digits and
possibly a sign, a decimal point and an exponent part, formed in an
appropriate way, like =-12.34e8= or =31=, and a symbol is a sequence
of "normal" characters -- most often lowercase letters, dashes and
a few others.  (It may even have digits, provided they do not form
a number; =+1= is not a symbol, while =1+= is.)  These rules are not
comprehensive (they are so simplified to be even wrong!), but they
suffice for the most cases.  There are also more kinds, or /types/, of
literal values, but they are fairly advanced and we will not cover
them in this tutorial.

An expression consisting of a literal value evaluates to itself: the
value of the expression =3.1416= is, unsurprisingly, the number
3.1416.  An expression consisting of a symbol evaluates the thing the
symbol names; if there is no such thing, an error occurs.

An expression is often a /list/, i.e., a sequence of /elements/,
separated by whitespace, and enclosed in parentheses, like this:

#+BEGIN_EXAMPLE
  (This is a list.)
#+END_EXAMPLE

The above list consists of four elements, and each of them is
a symbol.  Elements of lists need not be symbols.  They can be
literals (i.e., actual /values/), like numbers or strings, or even
other lists.

#+BEGIN_EXAMPLE
  ((This list) has 4 "elements.")
#+END_EXAMPLE

The first element of the above list is itself a list (consisting of
two elements -- both symbols), then another symbol, then a number,
then a string.

Not every list is a good candidate for an /expression/, though.  For
a list to serve as that, the first element should be something
special: most often, a symbol describing /what/ we want to happen.
The rest of the elements should explain /in what way/ we want that to
happen.  (The first element can be thought of as a /verb/ describing
an action, and the rest as /nouns/, objects for that action.)

Here is a simple example of a well-formed expression:

#+BEGIN_SRC elisp
  (+ 52 55)
#+END_SRC

It is not difficult to guess what it evaluates to.  How do we find out
whether we guessed correctly?

* Practicing Evaluation
There are quite a few ways for the Emacs user to evaluate an
expression and check what value it returns.  One of them is the aptly
named =eval-expression= command, by default bound to =M-:=.  Try it
now: press =M-:=, then type =(+ 52 55)= (don't forget the spaces!),
and hit =RET=.  You should see something like this:
#+BEGIN_EXAMPLE
107 (#o153, #x6b, ?k)
#+END_EXAMPLE
The result might be a bit surprising -- you probably expected to see
just =113= -- but when evaluating expressions returning whole numbers,
it is occasionally useful to see also the octal (153) and hexadecimal
(6b) values of the expression as well as the character whose code is
the expression's value, so that is what Emacs shows in this case.

Of course, retyping the expression you already have in some buffer is
not what you would like to do.  You may of course kill the expression
and yank it in the minibuffer when presented with the =M-:= prompt,
but there is another way.  In any mode (except maybe some really
exotic ones), you can place the point /after/ an expression and press
=C-x C-e= (or =M-x eval-last-sexp=).  (The "sexp" part is an
abbreviation of "s-expression", a fancy name for Lisp's kind of
expressions -- the ones enclosed in parentheses, and where the "verb"
comes at the beginning.)

You may now try evaluating various expressions, which sometimes leads
to surprises.  Try to guess what value the following expressions
return (some of them are cases of constructions we will cover later):

#+BEGIN_SRC elisp
  (/ 12 5)
  (/ 12 5.0)
  (* (+ 2 3) (/ 16 4))
  (concat "foo" "bar")
  (sleep-for 4)
  (point)
  (current-buffer)
  (buffer-name (current-buffer))
  (if (= 0 1)
      (message "Something is fishy!")
    (message "Numbers work as expected."))
  (mapcar #'sqrt '(1 2 3 4))
  (setq foo 42)
  (* foo foo)
#+END_SRC

Notice that the third expression is different than the others, in that
it contains another expression as one of its parts.  It is perfectly
valid -- and in fact, used all the time in Lisp programs -- since it
is the basic way of combining simple expressions to form more complex
ones.  When Emacs computes the value of an expression, and one of its
parts is an expression itself, Emacs pauses for a moment, computes the
value of the subexpression, and then substitutes the computed value in
place of that subexpression.  It is even possible (and very useful)
for the subexpression to contain further subexpressions, and this
chain is automatically properly resolved.

As you can see from some of the above examples, there exist various
"verbs" that can come as the first symbol in an expression.  In fact,
there exist /thousands/ of them -- the more packages you have
installed in your Emacs, the more such symbols exist.  (In my Emacs,
when I am typing this, I have 25849 of them.  In stock Emacs, without
any packages, there are more than 6000 of them.)  This number may seem
intimidating, but just like when learning a natural language, you do
not have to know all them to be able to communicate with its native
speakers comfortably.  Even if you know only a few dozen, you can
express quite a few things, and Emacs has much better facilities than
an ordinary dictionary to learn new ones.

There are more ways to evaluate Emacs Lisp expressions, but the ones
we have covered are enough for now.  Let us move on to explaining some
of the magic behind the example expressions above!

* Making lists and quoting
Many, many things in Emacs are /lists/.  For instance, the /kill ring/
is kept in a list.  Try =C-h v kill-ring RET= now to see it for
yourself.

But this begs a question: how to refer to a list inside a Lisp
program?  Since Lisp programs themselves are lists of expressions,
which are also (often) lists, how to distinguish between a list as
code and list as data?

The answer is: we should /quote/ the list.  When writing in English,
when you want the reader to understand that some words should be taken
literally, you can enclose them in quotes.  For instance, if you don't
want to sound uneducated, you may write

#+BEGIN_QUOTE
They sang "We don't need no education".
#+END_QUOTE

instead of

#+BEGIN_QUOTE
They sang that they didn't need no education.
#+END_QUOTE

In a similar vein, when you want Lisp to know that =(1 2 3)= is to be
taken literally as a list of numbers and not evaluated (and trying to
evaluate this list will result in error -- try it yourself!), you can
/quote/ it.  Unlike English, Lisp requires only one quote, at the
beginning (since the list is enclosed in parentheses and hence it is
obvious where it ends anyway), and uses the single quote (or
apostrophe) to quote lists, like this:

#+BEGIN_SRC elisp
  '(1 2 3)
#+END_SRC

If you evaluate this now (e.g., using =C-x C-e= in this very buffer),
instead of an error message you will get the result, which is the list
=(1 2 3)=.

In fact, the same mechanism applies also in other situations when we
don't want Lisp to evaluate something.  For instance, try to evaluate
this:

#+BEGIN_SRC elisp
  kill-ring
#+END_SRC

and this:

#+BEGIN_SRC elisp
  'kill-ring
#+END_SRC

As you can see, the value of the former expression (without the quote)
is what the name (or /variable/, which is a concept we will discuss
later) =kill-ring= /refers/ to (i.e., the contents of the kill ring),
and the value of the latter one (with the quote) is the name (symbol)
itself.  Believe it or not, this is sometimes useful.

Incidentally, the same list can be created in another way.  There is
a built-in function =list=, which takes as many arguments as you give
it (it's even happy with zero!) and returns a list made from all of
them.  Before you evaluate these expressions, try to guess which one
will result in an error!

#+BEGIN_SRC elisp
  (list 1 2 3)
  (list)
  (list 1 2 (list 3 4))
  (list 1 2 list)
  (list 1 2 'list)
#+END_SRC

If you actually did evaluate the above expressions, you may have
noticed something strange.  The result of the second expression was
not, as you may have expected, the /empty list/ =()=, but the word
=nil=.  Don't worry: it is exactly the same thing.  Whenever you are
allowed to write =()=, you can also write =nil=, and vice versa.  In
general, Elisp's =nil= is analogous to mathematics' empty set, or
shrugging in real life.  This is what a function returns when it has
nothing to say, for instance. (It also has other meanings, which we
will learn in a few minutes.)

You may ask, why would you want to write =(list 1 2 3)= when writing
='(1 2 3)= is shorter?  The short answer is: it is rarely the case
that you need some list in a Lisp program whose elements can be
predetermined at the time of writing the program, and if the contents
of the list shhould depend on something outside the control of the
programmer (like the contents of some buffer at the time of running
the program or the keys the user presses etc.), the quote notation
won't be of any use.  The longer answer is...  no, I won't give the
longer answer, since you cannot understand it now.  Just a warning;
memorize it now even if you do not understand it /at all/.  When the
undrestanding comes, and you will be in a situation when the subject
of it matters to you, you will thank me for that advice.  If you need
a literal list in your program, but you are going to apply any
destructive function on the variable containing that list, never,
/ever/ use the quote notation in your program.  You do not know it
yet, but I just saved you a /lot/ of headaches.   You are welcome.

* Side effects
In theory, the main result of evaluating the expression is its value.
In practice, we want our program do more things than just compute
something.  For instance, it is natural that an Emacs Lisp program
/modifies/ some buffer.

In computer science, we call any effects of evaluating an expression
/other/ than returning its value /side effects/.  This does not mean
that they are less important.  On the contrary, it is not unusual for
a Lisp expression to be evaluated only for the sake of its side
effects, and in such cases we often disregard its returned value.
Some functions even always return =nil=, because the /only/ reason for
their existence is side effects.

* Example: Adding some text at the end of the buffer
We studied quite a lot of theory, so let us now see an example.
Assume that we want to write a program which inserts some text at the
end of the buffer -- like =(c) 2016 <your name here>=.  This is
something we might imagine writing manually, and we might want to
write a program to make this faster, less boring and less
error-prone.

For simple Elisp programs doing manipulations on the buffer, it is
often the case that we can "mimic" the (manual) editing operations
leading to the desired result.  (In fact, Emacs has a special facility
precisely for "recording" some user actions, like keypresses -- the
so-called /keyboard macros/.  Elisp programs are much more powerful,
however.)  In this case, what we /could/ do is: press =M->=
(=end-of-buffer=), and then /type/ the text.

Our program could consist of two expressions:
#+BEGIN_SRC elisp
  (end-of-buffer)
  (insert "(c) 2016 Marcin Borkowski")
#+END_SRC
In the first expression you instantly recognize the name of Emacs
command called to get to the end of buffer.  The second one is roughly
the counterpart of typing the contents of the string.  (In fact,
=insert= is /always/ used for this side effect of its.  I can tell
that for sure, because it /always/ returns =nil=!)

You may try now to press =M-:= and enter the first expression, then
=M-:= again and enter the second.  It works, but is not very
convenient.

What are the problems with our approach?  First of all, we would
prefer to be able to evaluate our expressions /at once/ (i.e., in
quick succession, without having to manually enter one after the
other).  Then, we would probably prefer to write a /command/, so that
instead of typing something to the =M-:= prompt, we could say =M-x
insert-copyright-note=, or even bind it to some convenient key, like
=C-c c=.  The next thing could be ensuring that the copyright notice
starts on its own line.  Finally, instead of hard-coding the year and
the user's name, we might want to use the current year and ask the
system for the username to insert.

We will do all these in subsequent sections.


* Looping


* Variables and assignment

* Functions
* Conditionals

* Commands

* Introduction to debugging

* Potentially useful packages for Lisp editing
