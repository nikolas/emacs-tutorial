#+TITLE: The Emacs Lisp Introduction Tutorial
#+AUTHOR: Marcin Borkowski

* Introduction
This tutorial is meant to get you started with Emacs Lisp.

Nearly everything covered by this short tutorial (and much, much more)
can be learned from the official Emacs documentation (reading of which
I strongly recommend, especially the excellent Robert J. Chassell's
book, "Introduction to Programming in Emacs Lisp", which you can
access in Emacs by typing =C-h i d m emacs lisp intro RET= and which
is another introductory text on Emacs Lisp).  If you prefer, however,
to learn by doing, this tutorial may serve (hopefully) as a useful
assistance.

We do not assume knowledge of programing in general or in any language
in particular, but for the sake of those readers who happen to know
some popular programming language(s), remarks comparing Emacs Lisp to
them are sprinkled throughout the text.  You don't lose anything
important if you skip or don't understand them.

* Introduction to Emacs Lisp
Emacs Lisp is a member of the ancient and noble family of Lisp
programming languages.  (Its name is sometimes shortened to Elisp, and
we will use the more generic word "Lisp" from time to time, too.
There are excellent articles about the history of Lisp, and the
reasons it looks like this, so we will jump straight into examples.

A Lisp program consists of a sequence of /expressions/.  Each of them
is /evaluated/ in succession, and the evaluation of each one results
in a /value/ (we say that an expression /returns/ the value, or that
it /evaluates/ to it.).  Notice that there are no /statements/ in
Lisp, unlike languages like C or Python.  The thing closest to
a "statement" in Lisp is an expression whose value is not used.

An expression may be an /atom/.  An atom can be a /literal value/,
like a number or a string of characters, or something called
a /symbol/, which is a Lispy way of saying "a name for something".  (A
Lisp "symbol" is close to what other languages call an "identifier".
Lisp does not have a notion of a "reserved keyword".)  The rules to
decide which is which are rather simple: a /string/ is a sequence of
characters other than quotation marks, surrounded by quotation marks,
like ="string"=; a /number/ is something consisting of digits and
possibly a sign, a decimal point and an exponent part, formed in an
appropriate way, like =-12.34e8= or =31=, and a symbol is a sequence
of "normal" characters -- most often lowercase letters, dashes and
a few others.  (It may even have digits, provided they do not form
a number; =+1= is not a symbol, while =1+= is.)  These rules are not
comprehensive (they are so simplified to be even wrong!), but they
suffice for the most cases.  There are also more kinds, or /types/, of
literal values, but they are fairly advanced and we will not cover
them in this tutorial.

An expression consisting of a literal value evaluates to itself: the
value of the expression =3.1416= is, unsurprisingly, the number
3.1416.  An expression consisting of a symbol evaluates the thing the
symbol names; if there is no such thing, an error occurs.

An expression is often a /list/, i.e., a sequence of /elements/,
separated by whitespace, and enclosed in parentheses, like this:

#+BEGIN_EXAMPLE
  (This is a list.)
#+END_EXAMPLE

The above list consists of four elements, and each of them is
a symbol.  Elements of lists need not be symbols.  They can be
literals (i.e., actual /values/), like numbers or strings, or even
other lists.

#+BEGIN_EXAMPLE
  ((This list) has 4 "elements.")
#+END_EXAMPLE

The first element of the above list is itself a list (consisting of
two elements -- both symbols), then another symbol, then a number,
then a string.

Not every list is a good candidate for an /expression/, though.  For
a list to serve as that, the first element should be something
special: most often, a symbol describing /what/ we want to happen.
The rest of the elements should explain /in what way/ we want that to
happen.  (The first element can be thought of as a /verb/ describing
an action, and the rest as /nouns/, objects for that action.)

Here is a simple example of a well-formed expression:

#+BEGIN_SRC elisp
  (+ 52 55)
#+END_SRC

It is not difficult to guess what it evaluates to.  How do we find out
whether we guessed correctly?

* Practicing Evaluation
There are quite a few ways for the Emacs user to evaluate an
expression and check what value it returns.  One of them is the aptly
named =eval-expression= command, by default bound to =M-:=.  Try it
now: press =M-:=, then type =(+ 52 55)= (don't forget the spaces!),
and hit =RET=.  You should see something like this:
#+BEGIN_EXAMPLE
107 (#o153, #x6b, ?k)
#+END_EXAMPLE
The result might be a bit surprising -- you probably expected to see
just =113= -- but when evaluating expressions returning whole numbers,
it is occasionally useful to see also the octal (153) and hexadecimal
(6b) values of the expression as well as the character whose code is
the expression's value, so that is what Emacs shows in this case.

Of course, retyping the expression you already have in some buffer is
not what you would like to do.  You may of course kill the expression
and yank it in the minibuffer when presented with the =M-:= prompt,
but there is another way.  In any mode (except maybe some really
exotic ones), you can place the point /after/ an expression and press
=C-x C-e= (or =M-x eval-last-sexp=).  (The "sexp" part is an
abbreviation of "s-expression", a fancy name for Lisp's kind of
expressions -- the ones enclosed in parentheses, and where the "verb"
comes at the beginning.)

You may now try evaluating various expressions, which sometimes leads
to surprises.  Try to guess what value the following expressions
return (some of them are cases of constructions we will cover later):

#+BEGIN_SRC elisp
  (/ 12 5)
  (/ 12 5.0)
  (* (+ 2 3) (/ 16 4))
  (concat "foo" "bar")
  (sleep-for 4)
  (point)
  (current-buffer)
  (buffer-name (current-buffer))
  (if (= 0 1)
      (message "Something is fishy!")
    (message "Numbers work as expected."))
  (mapcar #'sqrt '(1 2 3 4))
  (setq foo 42)
  (* foo foo)
#+END_SRC

Notice that the third expression is different than the others, in that
it contains another expression as one of its parts.  It is perfectly
valid -- and in fact, used all the time in Lisp programs -- since it
is the basic way of combining simple expressions to form more complex
ones.  When Emacs computes the value of an expression, and one of its
parts is an expression itself, Emacs pauses for a moment, computes the
value of the subexpression, and then substitutes the computed value in
place of that subexpression.  It is even possible (and very useful)
for the subexpression to contain further subexpressions, and this
chain is automatically properly resolved.

As you can see from some of the above examples, there exist various
"verbs" that can come as the first symbol in an expression.  In fact,
there exist /thousands/ of them -- the more packages you have
installed in your Emacs, the more such symbols exist.  (In my Emacs,
when I am typing this, I have 25849 of them.  In stock Emacs, without
any packages, there are more than 6000 of them.)  This number may seem
intimidating, but just like when learning a natural language, you do
not have to know all them to be able to communicate with its native
speakers comfortably.  Even if you know only a few dozen, you can
express quite a few things, and Emacs has much better facilities than
an ordinary dictionary to learn new ones.

There are more ways to evaluate Emacs Lisp expressions, but the ones
we have covered are enough for now.  Let us move on to explaining some
of the magic behind the example expressions above!

* Making lists and quoting
Many, many things in Emacs are /lists/.  For instance, the /kill ring/
is kept in a list.  Try =C-h v kill-ring RET= now to see it for
yourself.

But this begs a question: how to refer to a list inside a Lisp
program?  Since Lisp programs themselves are lists of expressions,
which are also (often) lists, how to distinguish between a list as
code and list as data?

The answer is: we should /quote/ the list.  When writing in English,
when you want the reader to understand that some words should be taken
literally, you can enclose them in quotes.  For instance, if you don't
want to sound uneducated, you may write

#+BEGIN_QUOTE
They sang "We don't need no education".
#+END_QUOTE

instead of

#+BEGIN_QUOTE
They sang that they didn't need no education.
#+END_QUOTE

In a similar vein, when you want Lisp to know that =(1 2 3)= is to be
taken literally as a list of numbers and not evaluated (and trying to
evaluate this list will result in error -- try it yourself!), you can
/quote/ it.  Unlike English, Lisp requires only one quote, at the
beginning (since the list is enclosed in parentheses and hence it is
obvious where it ends anyway), and uses the single quote (or
apostrophe) to quote lists, like this:

#+BEGIN_SRC elisp
  '(1 2 3)
#+END_SRC

If you evaluate this now (e.g., using =C-x C-e= in this very buffer),
instead of an error message you will get the result, which is the list
=(1 2 3)=.

In fact, the same mechanism applies also in other situations when we
don't want Lisp to evaluate something.  For instance, try to evaluate
this:

#+BEGIN_SRC elisp
  kill-ring
#+END_SRC

and this:

#+BEGIN_SRC elisp
  'kill-ring
#+END_SRC

As you can see, the value of the former expression (without the quote)
is what the name (or /variable/, which is a concept we will discuss
later) =kill-ring= /refers/ to (i.e., the contents of the kill ring),
and the value of the latter one (with the quote) is the name (symbol)
itself.  Believe it or not, this is sometimes useful.

Incidentally, the same list can be created in another way.  There is
a built-in function =list=, which takes as many arguments as you give
it (it's even happy with zero!) and returns a list made from all of
them.  Before you evaluate these expressions, try to guess which one
will result in an error!

#+BEGIN_SRC elisp
  (list 1 2 3)
  (list)
  (list 1 2 (list 3 4))
  (list 1 2 list)
  (list 1 2 'list)
#+END_SRC

If you actually did evaluate the above expressions, you may have
noticed something strange.  The result of the second expression was
not, as you may have expected, the /empty list/ =()=, but the word
=nil=.  Don't worry: it is exactly the same thing.  Whenever you are
allowed to write =()=, you can also write =nil=, and vice versa.  In
general, Elisp's =nil= is analogous to mathematics' empty set, or
shrugging in real life.  This is what a function returns when it has
nothing to say, for instance. (It also has other meanings, which we
will learn in a few minutes.)

You may ask, why would you want to write =(list 1 2 3)= when writing
='(1 2 3)= is shorter?  The short answer is: it is rarely the case
that you need some list in a Lisp program whose elements can be
predetermined at the time of writing the program, and if the contents
of the list shhould depend on something outside the control of the
programmer (like the contents of some buffer at the time of running
the program or the keys the user presses etc.), the quote notation
won't be of any use.  The longer answer is...  no, I won't give the
longer answer, since you cannot understand it now.  Just a warning;
memorize it now even if you do not understand it /at all/.  When the
undrestanding comes, and you will be in a situation when the subject
of it matters to you, you will thank me for that advice.  If you need
a literal list in your program, but you are going to apply any
destructive function on the variable containing that list, never,
/ever/ use the quote notation in your program.  You do not know it
yet, but I just saved you a /lot/ of headaches.   You are welcome.

* Side effects
In theory, the main result of evaluating the expression is its value.
In practice, we want our program do more things than just compute
something.  For instance, it is natural that an Emacs Lisp program
/modifies/ some buffer.

In computer science, we call any effects of evaluating an expression
/other/ than returning its value /side effects/.  This does not mean
that they are less important.  On the contrary, it is not unusual for
a Lisp expression to be evaluated only for the sake of its side
effects, and in such cases we often disregard its returned value.
Some functions even always return =nil=, because the /only/ reason for
their existence is side effects.

* Example: Adding some text at the end of the buffer
We studied quite a lot of theory, so let us now see an example.
Assume that we want to write a program which inserts some text at the
end of the buffer -- like =(c) 2016 <your name here>=.  This is
something we might imagine writing manually, and we might want to
write a program to make this faster, less boring and less
error-prone.

For simple Elisp programs doing manipulations on the buffer, it is
often the case that we can "mimic" the (manual) editing operations
leading to the desired result.  (In fact, Emacs has a special facility
precisely for "recording" some user actions, like keypresses -- the
so-called /keyboard macros/.  Elisp programs are much more powerful,
however.)  In this case, what we /could/ do is: press =M->=
(=end-of-buffer=), and then /type/ the text.

Our program could consist of two expressions:
#+BEGIN_SRC elisp
  (end-of-buffer)
  (insert "(c) 2016 Marcin Borkowski")
#+END_SRC
In the first expression you instantly recognize the name of Emacs
command called to get to the end of buffer.  The second one is roughly
the counterpart of typing the contents of the string.  (In fact,
=insert= is /always/ used for this side effect of its.  I can tell
that for sure, because it /always/ returns =nil=!)

You may try now to press =M-:= and enter the first expression, then
=M-:= again and enter the second.  It works, but is not very
convenient.

What are the problems with our approach?  First of all, we would
prefer to be able to evaluate our expressions /at once/ (i.e., in
quick succession, without having to manually enter one after the
other).  Then, we would probably prefer to write a /command/, so that
instead of typing something to the =M-:= prompt, we could say =M-x
insert-copyright-note=, or even bind it to some convenient key, like
=C-c c=.  The next thing could be ensuring that the copyright notice
starts on its own line.  Finally, instead of hard-coding the year and
the user's name, we might want to use the current year and ask the
system for the username to insert.

We will do all these in subsequent sections.

* Functions
The first problem with our "program" is that it is not really
a /program/ -- it is just a pair of expressions, and we have to type
(or yank) them manually in the right order to achieve the desired
effect.  What we need is a way to /group/ them in a way that it will
be the machine's responsibility to evaluate them one after another.

Like in most common langauges, the means to this end in Elisp is by
using /functions/.  Function is exactly what we need: a group of
related expressions.  What is more important is what a function can
/do/ for us: a function may be /called/, which means that Emacs will
evaluate all the expressions constituting it in order they appear in
the function's definition.

Let us look at an example.  Here is our program, wrapped up in
a function:

#+BEGIN_SRC elisp
  (defun insert-copyright-note ()
    "Insert a copyright note at the end of the buffer."
    (end-of-buffer)
    (insert "(c) 2016 Marcin Borkowski"))
#+END_SRC
The value returned by the =(defun ...)= expression is irrelevant; this
expression is called for its side effect, which is to create
a function and associate a /name/ with it.

Let us look at this expression closer.  The first element of the list,
the symbol =defun=, signals to Elisp that we want to /de/fine
a /fun/ction.  The second element is the name we want our function to
have.  The third is an empty list, and we will talk about it later.
The fourth is the /docstring/, which will be shown by Emacs
self-documenting commands.  The rest are the expressions which make up
our function.

In order for our function to be defined, we have to evaluate this
expression.  We could do it by putting the point right after the last
closing parentesis and pressing =C-x C-e=, but there is a better way:
we can place the point /anywhere within the =defun= expression/ and
press =C-M-x= (=eval-defun=).  (This last binding works only in Emacs
Lisp major mode.)

By the way, it is worth noting that quite a lot of Emacs functions and
commands are defined in this (or similar) way.  At the time I'm
writing this, 1176 functions in my Emacs are defined internally in
C (the language the "core" of Emacs is written in), and the rest of
them is defined in Lisp via =defun= and similar facilities.  It
doesn't seem a big deal until we realize that /our function is treated
by Emacs as a first-class citizen; in fact, it potentially has access
to the same data and functions most of Emacs itself has/!  In other
word, what we have just written is not a /plugin/, which depends on
the author of the editor giving us access to /some/ possibilities of
the editor; it is now /part of Emacs/, just like, say, =find-file= or
=save-buffer= etc.

Only that it's not written well (yet).

* Commands
You may now try pressing =M-: (insert-copyright-note)=.  It works, but
still is far from perfect.  First of all, we want to make it
a command, so that we could call it with =M-x=.  This part is easy.
To mark a function for interactive use (i.e., to make it a command),
all we need to do is to put a special expression =(interactive)= right
after the docstring.  This expression does not /do/ anything (and when
/executing/ function, i.e., evaluating the expressions the function is
composed of, it returns =nil=), but it signals Emacs that this
function is a command and can be called with =M-x= or bound to a key.

Try it now: while =M-x insert-copyright-note= does /not/ work, after
evaluating this:
#+BEGIN_SRC elisp
  (defun insert-copyright-note ()
    "Insert a copyright note at the end of the buffer."
    (interactive)
    (end-of-buffer)
    (insert "(c) 2016 Marcin Borkowski"))
#+END_SRC
it suddenly does.

It is worth noting here that while many Emacs /commands/ are actually
/functions/, and hence they may be called in Lisp programs (like we
did), it does not mean they /should/.  For instance, many commands do
a lot of things which really only make sense when calling them
interactively, like setting the mark.  This is exactly the case with
=end-of-buffer=.

* Exploring Elisp
Let us stop for a minute and think about possible enhancements to the
above command.  The first thing is that it is not an especially good
idea to hardcode the year.  It would be much better to put the current
year in.  This is not very difficult.  First, we would like to know
which function returns the current date.  (I could just tell you that
now, but I'd like to teach you how to find out these things for
yourself!)  One way to learn about such function could be to read the
Emacs Lisp Reference, but there is a faster one.  Let's try to come up
with some string which could be part of that name: =M-x apropos RET
today RET=.  No luck – this doesn’t return any hits in stock Emacs.
(Incidentally, it /does/ find a few things in /my/ Emacs, but none of
those helps a lot.)  Now it’s time to get a bit creative.  What words
could describe the today’s date?  Here are two more candidates I can
think of: “date” and “current”.  =M-x apropos RET date RET= yields way
too many results (almost 70 on fresh Emacs, and more than 500 in my
normal Emacs session!).  Let’s filter all things like “update” out:
=M-x apropos RET \bdate\b RET= – much better, only about a dozen on
a fresh Emacs.  Unfortunately, none of those seem to do what we need.
Let’s try =M-x apropos RET current RET= (here we don’t need =\b=,
since there are not many words with the string “current” as
a subword).  This time we have to look through several dozen
candidates, but our effort is rewarded by the =current-time=
function.

The docstring says that it returns the Unix time in a rather weird
format.  We would like to be able to find out what the current /year/
is.  How do we know how to do that?  Let’s open the Emacs Lisp
Reference (=C-h i d m Elisp RET=), press =i= (for “index”) and type
=current-time=.  And here is a useful trick: you can now press =u=
(“up”) for a broader view (i.e., the parent section of the section
you’re in).  This quickly leads to the “Time Conversion” section,
where the first function is =decode-time= – and that’s exactly what we
needed!  (It turns out, by the way, that we don’t even need the
=current-time= function after all, since the first argument to
=decode-time= is optional, and defaults to “now”.)  Try now to
evaluate this:
#+BEGIN_SRC elisp
  (decode-time)
#+END_SRC
As you can see, we get a list whose sixth element is the current year
number.  Extracting it is now trivial:
#+BEGIN_SRC elisp
  (nth 5 (decode-time))
#+END_SRC
(The numeral =5= is here because =nth= returns, well, the nth element
of the list given, but it starts counting from zero.)

* Variables and assignment

* Conditionals

* Looping

* Introduction to debugging

* Potentially useful packages for Lisp editing
